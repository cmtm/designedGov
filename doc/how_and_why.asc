The how and why of designedGov
==============================
Chris Morin


:numbered:
== What is this document?

I've described my motivations for creating designedGov and what I hope to accomplish with designedGov project. I've also discussed how designGov solves current real world problems.

The protocol itself has been specified and I created a reference implementation, including clients, hosts and a certificate authority.

This document is an effort to show how the system comes together and why I designed as it is. I've written much attempting to justify the need for system itself, but documentation covering the justifications for the design are lacking. 

My main method will be describing and discussing generic use cases. By generic use cases, I mean examples of how the protocol was intended to be used. After having created a full reference implementation, there are some things I've changed and there are still many more things I've noticed can be improved but won't be in this iteration.

== Summary of designedGov: 

=== What designedGov seeks to do:

Give individuals and organizations (users) better access to their own information. This can be a patient's health records, a tax-payer's tax history or consumer's credit-card history.

Replace the current tedious, complex, error-prone and dangerous (from a security standpoint) way of moving this information around with a better one. Make this system automatable and transparent.

=== What is needed to accomplish do this

Establish a way for users to securely authenticate their own identity to anyone else, without the need of a third party or prior shared information.::

	To accomplish this, designGov use a public-key cryptography system with a single certificate authority. This certificate authority is run by the federal government. Each user will receive a signed certificate bonding their unique user ID to their public key. When a user wishes to communicate with another user, they can open a TLS connection and exchange their signed certificates for authentication.


A secure protocol for securely communicating arbitrary information between persons and organizations.::

	The protocol I designed to accomplish this is detailed in another document. It work by users exchanging objects called dgobs. A dgob can be one of various types such as a request. The initiating user (client) can send a request dgob to another user (server) in order to trigger an action or retrieve information. The server verifies the client has necessary authority and replies to the client with a response dgob appropriately.

An user friendly interface to allow users to communicate over this protocol.::
	
	Although human-readable, dgob objects aren't meant to be written by humans. Instead, a human interacts with a program which creates, exchanges and interprets dgobs on his behalf.

Have organizations interact with their clients through designedGov server applications.::

	Instead of using their own identity systems and communication methods, organizations will rely on authentication offered by the designedGov system and communicate with clients in compliance with the designedGov protocol.

=== How designedGov accomplishes this

As described before, desingedGov is not a single protocol, but a stack. This is to allow flexibility in both the initial designed of designedGov and future, unforeseen changes. A stack approach allows any layer to be replaced (as long as it's function is still fulfilled) without severely disrupting the others. <<stack>> shows the protocol stack, with each layer depending on the functionality of those under it.

[[stack]]
.Layers of designedGov
image::stack.png[scaledwidth="25%"]


==== Giving people access to their data

Typical designedGov transactions use all layers with the exception of the top one which isn't used when exchanges are automated. Let's take a look at a generic transaction in <<transaction>> of a person sending a single request object to a server, receiving the response, and then closing the connection.

The transaction in <<transaction>> is simpler than it looks at first glance: a lot of what is seen in the diagram is the system rejecting invalid certificates. We can see how all the layers come together.

* Client Interface: A user taking the role of a client sends his request through a client interface.

* Server application: The client interface communicates with the appropriate server application (rightmost actor in <<transaction>>).

* Communication protocol: Once the TLS connection is opened, all communication between the client interface and the server is done using the protocol.

* Certificate authority: The certificates presented in this transaction were both generated by the certificate authority. The client and server both got their certificates by previous transactions just like this one they made with the certificate authority.

* User definition: The user definition defines the users themselves (client and server in <<transaction>>). When a TLS connection is initiated and certificates are exchanged, each user verifies that the public key and the user ID match.

<<server>> only describes the communication between the actors, to better understand the system, let's take a look at the activity diagram for a generic server.

[[transaction]]
.Generic transaction
image::umlDiagrams/transaction.png[]

[[server]]
.Generic Server
image::umlDiagrams/server.png[]

The loop region in <<server>> shows us how a server responds to a request. As detailed in the protocol description, a request can have multiple request items so the server must loop over them. The basic procedure is to check for permissions, and then fulfill the request. The way it determines privileges is up to the server itself, though there are parts of the communication protocol which allow for basic privilege handling. The ambiguous "fulfill request" depends on the application and, of course, on what was requested. Lets see how a simple data read could fit into this diagram: the "check permissions" step could be a check that the user is requesting data in his own account (as opposed to someone else's data) and the "fulfill request" could be retrieving said data from a data base. Note that a lot of the error handling has been omitted from the diagram (e.g. the handling of an improperly structured request).

==== Moving that data around

We've just seen a simple example of desginedGov's capabilities. While it's much better than the traditional way of doing things because of the added security and convenience, it's hardly impressive. The real abilities of desginedGov lie in how it enables to secure motion of this information. With our current way of doing things, the way by which information is passed through the boundaries of organizations is determined by each organization. I'll use an example of someone paying their federal taxes to explain. The tax collecting agency requires that tax payers fill out their paper forms or, more recently, use their online web submission method (which itself requires a 3rd party tax preparation submission application, they don't produce their own). If a tax payer needs to supply information from an other organization to the tax collecting agency, they need to use yet another interface. This could be needing to get salary information from an employer or tuition slips from a school which then needs to be passed on to the tax collection agency. For each organization, in these "communication webs", the user needs to learn a new way of authenticating his/their identity and accessing the data. He must also often do the translation from one organization's format to another's, as is the case with needing to interpret a school tuition slip and get the right information for tax claims. designedGov provides an alternative to this.

Three parties are involved in typical exchange of these sorts. As with all desginedGov exchanges, they are all users The first is the subject party; a piece of the subject's personal information is what is being exchanged. The second is the consuming party; the party that wants the subject. The third is the producing party; the party that holds the subject (belonging to the user) that the consumer wants. The task at hand is to get the right data from the producer to the consumer securely and effectively.

There are two different ways of moving data in designedGov. The first involve direct communication between the producer and consumer, while the second doesn't. Instead of direct communication, the second method uses the user as a bridge between the consumer and producer such that all data passes through him. We'll look at the two methods below

===== Direct method

The direct method works by having the producer and consumer exchange data directly, without the intervention of the subject. The consumer sends a request for the data to the producer and the producer checks for permissions and responds appropriately. If this sounds similar to the generic transaction we saw in <<transaction>>, that's because it is a generic transaction. In this exchange, the consumer opens a TLS connection with the producer, all credentials are verified and then the requests are followed by the responses. Almost all designedGov transactions fall under this category. This flexibility and consistency is a big part of what gives designedGov it's security and ease of use.

What makes this type of transaction different from the simple case of a user requesting his own data is that the consumer doesn't own the data. We therefore have to be very careful with ensuring the consumer is actually allowed access to the data (designedGov feasibility depends on it!). A simple transaction gets all of it's security guarantees by using the tried and true TLS. While the consumer - producer type of transaction does use TLS to ensure secure communication and authentication, TLS says nothing about privileges: we have to build it into desginedGov.

In figure <<direct>>, we can see a generic direct method exchange. Notice that the subject isn't active in the exchange; he was included in the diagram to highlight this.

[[direct]]
.Generic direct method of exchange
image::umlDiagrams/direct.png[]

.Global permissions

As is discussed in other documents, organizations running designedGov server applications represent the data they hold as trees. There are two distinct types of trees: actual user data and templates. The actual user data is a tree which contains the information of a single client. There are therefore as many of these trees as there are clients. These trees are private to the client that owns them. On the other hand, only one template exists per organization application [TODO: note about possible change]. This template is public and describes the common structure of the data in the accounts held by the organization. The templates also describe what kind of operations can be performed on data and the *global permissions* the data is subject too. In the common case, a user alone will have read permission on his data and be able to call all actions. The template can specify a list of users other than the owner who have permission to read data or call actions. This list is attached to a node in the tree and applies to all of it's children. Since the template is unique in the organization application and all user accounts follow it, any users specified to have certain permissions have these permissions over all accounts. This is a very powerful privilege and so it must be used wisely.

This privilege scheme is intended to be used when it's only natural that the consumer has access to the subject's information and they need access to it regularly. The consumer could just keep track of the information himself, but this would create a duplicate of the information. Having duplicate information isn't convenient because the subject must then worry about keeping them all consistent and up-to-date.

.Local permissions

Similarly to the template tree, a users account tree can hold meta-data which specifies privileges. Unlike those in the template tree these privileges apply to his account alone. The _template tree_ dictates what *local permissions* can be granted by the user and if permitting, a user can grant access to parts of his account to a third party (consumer). The permissions he grants are placed in his _user account tree_ The organization hosting the application must decide what permissions a user should be able to share. While the permissions themselves are local, the rules governing _which_ permissions a user can grant are global and apply to all accounts (it's specified in the template). Restricting a user from granting certain permissions is a safety mechanism; it's to prevent them from shooting themselves in the foot. The rules should be restrictive; as a rule of thumb, permissions should only be grantable if a large enough amount of the user-base would have a good reason to grant them.

This permission scheme was created with the intention of enabling the same kind of exchanges as the global scheme. The difference however is that it handles cases where the consumer won't be the same for all the users despite the reason for exchange being the same. An example could be giving your employer the ability to make deposits to your bank account. Even though most bank accounts share the need for salary direct deposit capabilities, not all users share the same employer (most will probably have different ones) so each user must grant privileges to his own employer.

===== Indirect method

The second method of exchanging data between the consumer and producer doesn't involve any direct communication between them. Instead, the subject gets the data from the producer and then passes it on to the consumer. Each of these two transactions are normal transactions.

The problem with this method as it is is that the consumer has no guarantee that the data he receives from the subject is accurate. The subject might have an incentive in lying about his own information. For example, a user could lie about his salary to the tax collection agency to lessen his tax burden. In this case, the producer is the employer of the user.

To solve this, designedGov uses a cryptographic tool called digital signing. Much like a human signing a document with a pen, it's easy to validate the authenticity of a digital signature, while it's difficult to forge. We apply this by having the subject ask the producer that he sign the data he's requesting. That way, the consumer can have a guarantee that the information he's receiving is in fact from the producer as he has the ability to verify it's signature.

[[indirect]]
.Generic indirect method of exchange
image::umlDiagrams/indirect.png[]

The advantage of this method that it completely eliminates the need for any kind of permission scheme. The subject gets to decide whether he believes the consumer should have access to the information.

This is intended to be the go to way of moving information around. If you think about it, most exchanges crossing multiple organizational boundaries don't reoccur with a high enough frequency to make using this method too inconvenient for the subject since an organization keeps most of the information it regularly needs. That being said the act of relaying the information around can be automated by the client interface. This gives designedGov a lot of flexibility because adding new data flow paths doesn't involve modifying the both server applications and their permissions, but simply modifying the client interface.

==== How it comes together

The philosophy I chose to follow when dealing with moving data was to keep it simple. Through it's simplicity, it attains security, functionality and flexibility. The main way to move information around is the indirect way. Unlike the direct way, the indirect way doesn't require a permission scheme; the subject is responsible for deciding what information a consumer should have access to. This allows the permission scheme to be simpler (i.e. have less functionality) and so more secure.

The indirect way is very flexible since at any time an organization can ask for more information without needing to involve the producer. With the direct method on the other hand, the consumer and producer must coordinate the update of their systems since the consumer can't get the information before the producer also updates their system. If an organization decides they need a new piece of information about their clients, they can't get it right away but must convince the producer that they should grant them access or give the users the ability to grant access if they don't already have it. The producer then has the painful responsibility of determining if they have a good enough reason to comply. This can include security screening and informing/getting the consent to share information from it's current clients, not to mention the trouble of updating the system.

This scenario is very different in the indirect way, since the consumer needs only ask the clients for more information. Good client interfaces would be able to let a user move the data by specifying the consumer and producer without the path having been programmed into it, but if need be it could later be updated to make this operation easier for the user. If a client interface uses a plug-in system, it could the consumer could just release an updated version of his plug-in to automate this new data motion (with the user's permission of course).

===== Example: Filing taxes

Using these exchange methods as building blocks, any kind of exchange can be made. We've been mentioning the case of supplying supporting documents to a tax collection agency so let's look at a full tax filling example. There are two scenarios: one in which the client interface used by the tax-payer is sophisticated and automates the process and one where it's primitive and doesn't.

In this mock tax-filing, a taxpayer must provide supporting documents from his employer and his school to the tax agency. The tax agency also requires his address and telephone number which is held by an organization in charge of centralizing basic information about people (to avoid data duplication mentioned earlier). This organization will be called the "Basic Information Organization" or BIO for short. The tax agency has global read permissions over the addresses and telephone numbers held by the BIO, so it can get that information using the direct method.


<<primitive>> shows us how the tax filing would occur in the scenario where the tax-filer only has access to the primitive client interface. The tax-payer has to go through the trouble of making two transactions, one to get the document from the school, and the other for the actual tax submission.

[[primitive]]
.Tax filing process using a primitive client interface
image::umlDiagrams/primitive.png[]

<<sophisticated>> shows us how the tax filing would occur with the sophisticated the tax-payer only needs to do one "operation". All the exchanges are then orchestrated by the intelligent client interface

[[sophisticated]]
.Tax filing process using a sophisticated client interface
image::umlDiagrams/sophisticated.png[]

It's easy to confuse the direct/indirect difference with the automated/un-automated difference. Look again at <<primitive>> and <<sophisticated>> and notice that the the transactions are the same type (type being direct or indirect) between them. Just because the client interface is smarter, it doesn't change how the data is moved around; look at how the client interface communicated with the servers and you'll see that the exact same thing is happening in both figures. The only difference between them is that the primitive version needs the tax-payer to direct it on both transactions.

This example is only to illustrate how to data will move around, so what "filing taxes" actually entails was left unspecified. Lets take a quick look at what it could be though. In our current system, it involves filling out forms with declarations of earnings and other such claims. This could be handled in designedGov by having a client interface ask the tax-payer a series of questions and make the tax submission from the answers. This tax-filing interface would also fetch all the necessary supporting documents (with possible instructions from the user in the case of the primitive client). From these inputs (i.e. the answers from the tax-payer and his documents) the client interface could build up a dgob complying to the tax agencies requirements. Dgobs can contain arbitrary data, even other dgobs. The supporting documents could therefore be nested into the submission, along with any other required dgobs such as a payment authorization from a bank.